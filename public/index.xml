<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jernej Strasner</title>
    <link>http://jernejstrasner.com/</link>
    <description>Recent content on Jernej Strasner</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Jernej Strasner</copyright>
    <lastBuildDate>Wed, 08 Jul 2015 15:47:48 +0200</lastBuildDate><atom:link href="http://jernejstrasner.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Testing Throwable Methods in Swift 2</title>
      <link>http://jernejstrasner.com/posts/2015-07-08-testing-throwable-methods-in-swift-2/</link>
      <pubDate>Wed, 08 Jul 2015 15:47:48 +0200</pubDate>
      
      <guid>http://jernejstrasner.com/posts/2015-07-08-testing-throwable-methods-in-swift-2/</guid>
      <description>With the addition of error handling to Swift 2, we got a way to deal with errors with the nice try/catch exception handling syntax from many languages, but without the associated cost of stack unwinding.
As with anything new, some questions come to mind. How do we test methods that can throw errors? In Objective-C we had a few XCTest assert macros to help with this, like XCTAssertThrows. Swift 1 does not support exceptions, so these macros, which get translated to Swift functions, are absent from the XCTest framework in Swift.</description>
    </item>
    
    <item>
      <title>NSFastEnumeration in Swift</title>
      <link>http://jernejstrasner.com/posts/2015-07-06-nsfastenumeration-in-swift/</link>
      <pubDate>Wed, 01 Oct 2014 11:42:36 +0200</pubDate>
      
      <guid>http://jernejstrasner.com/posts/2015-07-06-nsfastenumeration-in-swift/</guid>
      <description>I spent the past few weeks digging into Swift while working on PSPDFKit. Today I was trying to enumerate a directory recursively. I resorted to NSFileManager and its method enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:. It returns an NSDirectoryEnumerator object which supports NSFastEnumeration. That means you can use the for-in loop in Objective-C. Without thinking, I wrote a for-in loop in Swift. Not so fast.
 Type NSDirectoryEnumerator does not conform to protocol SequenceType.
 Apple should have supported this.</description>
    </item>
    
    <item>
      <title>Singleton Pattern in Swift</title>
      <link>http://jernejstrasner.com/posts/2015-07-06-singleton-pattern-in-swift/</link>
      <pubDate>Sat, 07 Jun 2014 14:20:26 +0200</pubDate>
      
      <guid>http://jernejstrasner.com/posts/2015-07-06-singleton-pattern-in-swift/</guid>
      <description>Like just about any other iOS developer, I was caught completely by surprise when Apple announced Swift. I was expecting modest improvements to Objective-C, maybe even an Objective-C 3.0 release, but nothing as wild as a new language. But I got excited, really excited, when I watched the state of the union video (no, I was not one of the lucky WWDC ticket lottery winners). I started reading the Swift book right away.</description>
    </item>
    
    <item>
      <title>Smooth gradients on iOS/OSX</title>
      <link>http://jernejstrasner.com/posts/2013-10-17-smooth-gradients-ios/</link>
      <pubDate>Wed, 08 Jan 2014 23:00:00 +0000</pubDate>
      
      <guid>http://jernejstrasner.com/posts/2013-10-17-smooth-gradients-ios/</guid>
      <description>UPDATE: Updated for Swift, Swift 2 and packaged into a drop-in replacement for UIView.
I thought drawing gradients on iOS is easy. Well, until our designer gave me this:
I went on and implemented the drawRect: method on a custom UIView. I used CGGradient and wrote the drawing code. I ran the project in the simulator and noticed that the gradient was quite different. Ran on the device, same thing.</description>
    </item>
    
    <item>
      <title>The ternary operator in C</title>
      <link>http://jernejstrasner.com/posts/2013-07-24-c-ternary-operator/</link>
      <pubDate>Wed, 24 Jul 2013 12:58:00 +0000</pubDate>
      
      <guid>http://jernejstrasner.com/posts/2013-07-24-c-ternary-operator/</guid>
      <description>Most programmers are familiar with the ternary operator ?: that is available in C and most other languages. But what some people may not know is that you can also use this operator with only two arguments.
Instead of writing
int y = 23; int x = (y ? y : 34); you can do this
int y = 23; int x = (y ?: 34); The other thing some of you may not know is that when defining a const you can&amp;rsquo;t use an if statement to define it based on a condition, but you can do this:</description>
    </item>
    
  </channel>
</rss>
